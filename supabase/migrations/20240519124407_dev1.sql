create table "public"."links" (
    "created_at" timestamp with time zone not null default now(),
    "link_url" text not null,
    "link_type" text not null,
    "link_clicks" integer not null default 0,
    "link_label" text not null,
    "id" uuid not null default gen_random_uuid(),
    "page_id" uuid
);


alter table "public"."links" enable row level security;

create table "public"."pages" (
    "created_at" timestamp with time zone not null default now(),
    "page_handle" text,
    "user_id" uuid not null,
    "bio" text default ''::text,
    "page_name" text default ''::text,
    "avatar_id" text,
    "is_default" boolean default false,
    "id" uuid not null default gen_random_uuid(),
    "links_sort_order" uuid[] not null default '{}'::uuid[]
);


alter table "public"."pages" enable row level security;

create table "public"."waitlist" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "email" text not null,
    "name" text,
    "status" text default 'pending'::text,
    "joined_at" date default now()
);


alter table "public"."waitlist" enable row level security;

CREATE UNIQUE INDEX links_duplicate_pkey ON public.links USING btree (id);

CREATE UNIQUE INDEX pages_duplicate_pkey ON public.pages USING btree (id);

CREATE UNIQUE INDEX pages_duplicate_user_handle_key ON public.pages USING btree (page_handle);

CREATE UNIQUE INDEX pages_duplicate_user_id_key ON public.pages USING btree (user_id);

CREATE UNIQUE INDEX waitlist_email_key ON public.waitlist USING btree (email);

CREATE UNIQUE INDEX waitlsit_pkey ON public.waitlist USING btree (id);

alter table "public"."links" add constraint "links_duplicate_pkey" PRIMARY KEY using index "links_duplicate_pkey";

alter table "public"."pages" add constraint "pages_duplicate_pkey" PRIMARY KEY using index "pages_duplicate_pkey";

alter table "public"."waitlist" add constraint "waitlsit_pkey" PRIMARY KEY using index "waitlsit_pkey";

alter table "public"."links" add constraint "links_page_id_fkey" FOREIGN KEY (page_id) REFERENCES pages(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."links" validate constraint "links_page_id_fkey";

alter table "public"."pages" add constraint "pages_duplicate_user_handle_key" UNIQUE using index "pages_duplicate_user_handle_key";

alter table "public"."pages" add constraint "pages_duplicate_user_id_key" UNIQUE using index "pages_duplicate_user_id_key";

alter table "public"."pages" add constraint "pages_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."pages" validate constraint "pages_user_id_fkey";

alter table "public"."waitlist" add constraint "waitlist_email_key" UNIQUE using index "waitlist_email_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.increment_link_clicks(link_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  update public.links
  set link_clicks = link_clicks + 1
  where id = link_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_page()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.pages (user_id, is_default)
  values (new.id, true);
  return new;
end;
$function$
;

grant delete on table "public"."links" to "anon";

grant insert on table "public"."links" to "anon";

grant references on table "public"."links" to "anon";

grant select on table "public"."links" to "anon";

grant trigger on table "public"."links" to "anon";

grant truncate on table "public"."links" to "anon";

grant update on table "public"."links" to "anon";

grant delete on table "public"."links" to "authenticated";

grant insert on table "public"."links" to "authenticated";

grant references on table "public"."links" to "authenticated";

grant select on table "public"."links" to "authenticated";

grant trigger on table "public"."links" to "authenticated";

grant truncate on table "public"."links" to "authenticated";

grant update on table "public"."links" to "authenticated";

grant delete on table "public"."links" to "service_role";

grant insert on table "public"."links" to "service_role";

grant references on table "public"."links" to "service_role";

grant select on table "public"."links" to "service_role";

grant trigger on table "public"."links" to "service_role";

grant truncate on table "public"."links" to "service_role";

grant update on table "public"."links" to "service_role";

grant delete on table "public"."pages" to "anon";

grant insert on table "public"."pages" to "anon";

grant references on table "public"."pages" to "anon";

grant select on table "public"."pages" to "anon";

grant trigger on table "public"."pages" to "anon";

grant truncate on table "public"."pages" to "anon";

grant update on table "public"."pages" to "anon";

grant delete on table "public"."pages" to "authenticated";

grant insert on table "public"."pages" to "authenticated";

grant references on table "public"."pages" to "authenticated";

grant select on table "public"."pages" to "authenticated";

grant trigger on table "public"."pages" to "authenticated";

grant truncate on table "public"."pages" to "authenticated";

grant update on table "public"."pages" to "authenticated";

grant delete on table "public"."pages" to "service_role";

grant insert on table "public"."pages" to "service_role";

grant references on table "public"."pages" to "service_role";

grant select on table "public"."pages" to "service_role";

grant trigger on table "public"."pages" to "service_role";

grant truncate on table "public"."pages" to "service_role";

grant update on table "public"."pages" to "service_role";

grant delete on table "public"."waitlist" to "anon";

grant insert on table "public"."waitlist" to "anon";

grant references on table "public"."waitlist" to "anon";

grant select on table "public"."waitlist" to "anon";

grant trigger on table "public"."waitlist" to "anon";

grant truncate on table "public"."waitlist" to "anon";

grant update on table "public"."waitlist" to "anon";

grant delete on table "public"."waitlist" to "authenticated";

grant insert on table "public"."waitlist" to "authenticated";

grant references on table "public"."waitlist" to "authenticated";

grant select on table "public"."waitlist" to "authenticated";

grant trigger on table "public"."waitlist" to "authenticated";

grant truncate on table "public"."waitlist" to "authenticated";

grant update on table "public"."waitlist" to "authenticated";

grant delete on table "public"."waitlist" to "service_role";

grant insert on table "public"."waitlist" to "service_role";

grant references on table "public"."waitlist" to "service_role";

grant select on table "public"."waitlist" to "service_role";

grant trigger on table "public"."waitlist" to "service_role";

grant truncate on table "public"."waitlist" to "service_role";

grant update on table "public"."waitlist" to "service_role";

create policy "Enable delete for users based on user_id"
on "public"."links"
as permissive
for delete
to authenticated
using ((auth.uid() IN ( SELECT pages.user_id
   FROM pages
  WHERE (pages.id = links.page_id))));


create policy "Enable insert for authenticated users only"
on "public"."links"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT pages.user_id
   FROM pages
  WHERE (pages.id = links.page_id))));


create policy "Enable read access for all users"
on "public"."links"
as permissive
for select
to public
using (true);


create policy "Enable update for authenticated"
on "public"."links"
as permissive
for update
to authenticated
using ((auth.uid() IN ( SELECT pages.user_id
   FROM pages
  WHERE (pages.id = links.page_id))))
with check ((auth.uid() IN ( SELECT pages.user_id
   FROM pages
  WHERE (pages.id = links.page_id))));


create policy "Auth Users can create pages"
on "public"."pages"
as permissive
for insert
to authenticated
with check (true);


create policy "Auth users can update"
on "public"."pages"
as permissive
for update
to authenticated
using (true)
with check (true);


create policy "Enable read access for all users"
on "public"."pages"
as permissive
for select
to public
using (true);


create policy "can delete own pages"
on "public"."pages"
as permissive
for delete
to authenticated
using ((auth.uid() IN ( SELECT pages_1.user_id
   FROM pages pages_1
  WHERE (pages_1.id = pages_1.id))));


create policy "Anyone can insert into waitlist"
on "public"."waitlist"
as permissive
for insert
to public
with check (true);


create policy "anyone can pull from waitlist"
on "public"."waitlist"
as permissive
for select
to public
using (true);



